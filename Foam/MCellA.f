*///////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                       //
*//             MCell  Mega Cell MC sampler                                               //
*//             Version 2.02 November 2000                                                //
*//                                                                                       //
*//  N-dimensional general purpose Monte Carlo sampler                                    //
*//  with the self-adapting HYPER-CUBICAL grid                                            //
*//                                                                                       //
*//             Author:   Stanislaw JADACH                                                //
*//             Address:  INP Cracow, DESY-Zeuthen                                        //
*//             Email:    Stanislaw.Jadach@cern.ch, Stanislaw.Jadach@ifj.edu.pl           //
*//             HomePage: http://home.cern.ch/jadach/                                     //
*//                                                                                       //
*//  First version 1.00 written by S.J. in August 2000 during visit in DESY-Zeuthen       //
*///////////////////////////////////////////////////////////////////////////////////////////


*/////////////////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                                     //
*//          Pseudoclass MCellA                                                                         //
*//                                                                                                     //
*//                                                                                                     //
*//                      Initialization of the grid                                                     //
*//  MCellA_PreInitialize                 : Pre-initialization, set all default values (constructor?)   //
*//  MCellA_Initialize(FunW)              : Initialization of the grid etc.                             //
*//  MCellA_InitCells                     : Initializes first n-factorial cells inside original cube    //
*//  MCellA_DefCell                       : Create new (daughter) cell and append at end of the buffer  //
*//  MCellA_Explore(iCell,funW)           : Short MC sampling in iCell, determine <wt>, wtMax etc.      //
*//  MCellA_RanDiscr(Driv,nTot,Power,iRand) : Random choice of cell division direction                  //
*//  MCellA_MakeAlpha(Alpha)              : auxiliary procedure for MCellA_Explore                      //
*//  MCellA_Grow(funW)              : grow cells until buffer is full                                   //
*//  MCellA_PeekMax(iCell)          : choose randomly one cell, used also in MC generation              //
*//  MCellA_PeekRand1(iCell)        : Generates randomly one (active) cell pointer iCell                //
*//  MCellA_Divide(iCell,funW,RC)   :Divide iCell into two daughters; iCell retained, taged as inactive //
*//  MCellA_ActUpda                 : Creates list of active cells (pointers)                           //
*//                     Generation                                                                      //
*//  MCellA_MakeEvent(Density)      : Generates point/vector Xrand with the weight MCwt                 //
*//  MCellA_CellGener(Density)      : Cooses randomly one of active cells                               //
*//  MCellA_GetMCvector(MCvector)   : Provides point/vector MCvector generated by  MakeEvent            //
*//  MCellA_GetMCwt(MCwt)           : Provides MCwt, MC weight calculated by MakeEvent                  //
*//  MCellA_MCgenerate(funW,X,MCwt) : Alternative entry, Generates point X with the weight MCwt         //
*//                     Finalization                                                                    //
*//  MCellA_Finalize(MCresult,MCerror)    : Calculates integral and its error after (only from) MC run  //
*//                     Other Getters and Setters                                                       //
*//  MCellA_GetTotPrim(TotPrim)     !Provides Prrimary used in MC generation                            //
*//  MCellA_SetKdim(Kdim)           :Sets no. of dimensions hypercubics (to be called before Initialize)//
*//  MCellA_SetnBuf(nBuf)           :Sets nBuf, working area in buffer                                  //
*//  MCellA_SetnBin(nBin)           :Sets nBin, histogram size for cell exploration/division            //
*//  MCellA_SetOut(Out)             :Sets output unit number                                            //
*//  MCellA_SetChat(Chat)           :Sets chat level; Chat=0,1,2 chat level in output, Chat=1 normal    //
*//  MCellA_SetnSampl(nSampl)       :Sets nSampl; No of MC sampling before dividing cell                //
*//  MCellA_SetOptDrive(OptDrive)   :Sets OptDrive; type of Driver =0,1,2 for True,Sigma,WtMax          //
*//  MCellA_SetOptPeek              :Sets type of method in cell division                               //
*//  MCellA_SetOptEdge(OptEdge)     :Sets OptEdge; decides whether vertices are included in the sampling//
*//  MCellA_SetOptRanIni(OptRanIni) :Sets OptRanIni=0,1, for rand. numb. initialization inside/outside  //
*//  MCellA_SetOptRanLux(OptRanLux) :Sets OptRanLux=-1,0,1,2,3 raand.numb.gen. level                    //
*//  MCellA_GetnCalls(nCalls)       :Get total no of function calls                                     //
*//                    Debugging and miscelaneous                                                       //
*//  MCellA_Check(mout,level)       :Checks all pointers (after comression) debuging!                   //
*//  MCellA_BufPrint(mout)          :Prints all cells, debugging                                        //
*//  MCellA_BufActPrint(mout)       :Prints all active cells, debugging                                 //
*//  MCellA_PltBegin                :Ploting 2-dim. cells and vertices                                  //
*//  MCellA_PltCell(mout)           :Ploting 2-dim. cells and vertices                                  //
*//  MCellA_PltEnd                  :Ploting 2-dim. cells and vertices                                  //
*//                                                                                                     //
*/////////////////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                                     //
*//  Input parameters:                                                                                  //
*//    kDim     number of dimensions for hypercubics                                                    //
*//    nBuf     Actual dynamic lenth of the buffer m_nBuf<m_nBufMax. For strongly peaked distribution   //
*//             nBuf should be as large as possible, this will increase CPU time in initialization      //
*//             MC generation is weakly affected by increasing nBuf                                     //
*//    nSampl   No of sampling when dividing cell, nSampl=10-100 is OK, further increase improves       //
*//             costs CPU time and apparently does not increase grid efficiency too much.               //
*//             This should be checked however for every new distribution.                              //
*//    OptDrive Type of Driver =0,1,2 for TrueInt,Sigma,WtMax, Driver=WtMax is the best if we aim       //
*//             at rejection leading to wt=1 events. If not then Driver=Sigma iswiser choice leading    //
*//             to save of CPU time.  Simplistic Driver=Sigma is correct but not recommeneded (ineffic.)//
*//    OptEdge  decides whether vertices are included in the sampling. Default  OptEdge=1 causes that   //
*//             vertices at the edge of simplex cells are included always in MC exploration             //
*//             of the cell. In the case of density distrib. with weak integrable singularities         //
*//             at the edges it may be not possible and OptEdge=0 may help.                             //
*//    EvPerBin Enhancement of MC statistics in the beginning of the foam build-up (testing new ideas). //
*//             =0 (default) no enhacement, =0 enhancement is none, fo hyp-cubic foeam only.            //
*//    Out      Miscelaneous. Output unit number.                                                       //
*//    Chat     Miscelaneous. Chat=0,1,2 chat level in output, Chat=1 normal level.                     //
*//                                                                                                     //
*//                                                                                                     //
*/////////////////////////////////////////////////////////////////////////////////////////////////////////
*//  Terminology:                                                                                       //
*//    "Active cells" are these which did not divide and are eligible for division                      //
*//  Remarks:                                                                                           //
*//    List of active cells is not realy necessary, but let us keep it for possible                     //
*//    future developements or tests.                                                                   //
*/////////////////////////////////////////////////////////////////////////////////////////////////////////


      SUBROUTINE MCellA_PreInitialize     !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Presets certain defaults for switches and other and regualtory parameters.     //
*//   They Can be reset with setters                                                 //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER i,j
*
      INTEGER   m_Magic        ! Magic cookie, to avoid multiple initialization
      DATA      m_Magic /378231178/
      SAVE      m_Magic
*     -------------------------------------------------
      IF(m_Magic .EQ. 378231178 ) THEN
         m_MagicInit = m_Magic
         m_Magic     = 0
      ENDIF
      IF(m_MagicInit .NE. 378231178 ) RETURN
      IF(m_Chat.GT.0) THEN
         WRITE(m_out,*) '================================================' !
         WRITE(m_out,*) '===============MCellA_PreInitialize==============' !
         WRITE(m_out,*) '================================================' !
      ENDIF
      m_MagicInit= 0
      m_kDim     = 0                 ! dimension hypercubics
      m_Dimen    = m_kDim            ! dimension total
      m_nBuf     = 1000              ! Actual dynamic lenth of the buffer m_nBuf<m_nBufMax
      m_nBin     = 8                 ! No of histogram bins in exploring cell 
      m_nSampl   = 200               ! No of sampling when dividing cell
      m_OptDrive = 2                 ! type of Driver =0,1,2 for TrueVol,Sigma,WtMax
      m_OptEdge  = 0                 ! decides whether vertices are included in the sampling
      m_OptPeek  = 1                 ! type of Peek =0,1 for maximum, random
      m_Out      = 6                 ! Output unit
      m_Chat     = 1                 ! Chat=0,1,2 chat level in output, Chat=1 normal level
      m_OptRanIni= 1                 ! Rand.num. generator initialized (=1) inside MCellA
      m_OptRanLux= 3                 ! Rand.num. generator level =-1,0,1,2,3,4
      m_EvPerBin =25                 ! Cut MC statistics in the end of build-up <m_EvPerBin*nBin
*
      m_LastCe   = 0                 ! Initial length of dynamical buffor for cells
      m_nCalls   = 0                 ! Initial counter of function calls
      END

      SUBROUTINE MCellA_Flush        !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Use this before re-initialization of the MCellA                                //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      m_MagicInit = 378231178   ! Reset Magic cookie, alowing initialization
      IF(m_Chat.GT.0) THEN
         WRITE(m_out,*) '========================================'
         WRITE(m_out,*) '===============MCellA_Flush=============='
         WRITE(m_out,*) '========================================'
      ENDIF
      CALL MCellA_PreInitialize
      END

      SUBROUTINE MCellA_Initialize(FunW)     !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Basic initialization, create "foam of cells"                                   //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      DOUBLE PRECISION   funW
      EXTERNAL           funW
      INTEGER            i,j,k,iCell,kCell
      DOUBLE PRECISION   TotPrim
*---------------------------------------------
      CALL MCellA_PreInitialize
* User may prefers to initialize r.n.gen. by himsef, the initialization below can be inhibited 
      IF( m_OptRanIni.EQ. 1 ) THEN
         IF(m_OptRanLux.EQ.-1) THEN
            CALL PseuMar_Initialize(54217137, 0, 0) ! Initialization of random number generator
         ELSEIF(m_OptRanLux.GE.0 .AND. m_OptRanLux.LE.4 ) THEN
            CALL RLUXGO( m_OptRanLux, 54217137,0,0) ! Initialization of random number generator
         ELSE
            WRITE(*,    *) ' ### STOP in MCellA_Initialize, wrong OptRanLux =',m_OptRanLux !
            WRITE(m_Out,*) ' ### STOP in MCellA_Initialize, wrong OptRanLux =',m_OptRanLux !
         ENDIF
      ENDIF
*
      IF( m_nBuf .GT. m_nBufMax) THEN
         WRITE(*,    *) ' ### STOP in MCellA_Initialize, to big m_nBuf =',m_nBuf !
         WRITE(m_Out,*) ' ### STOP in MCellA_Initialize, to big m_nBuf =',m_nBuf !
         STOP
      ENDIF
      IF( m_nBin .GT. m_nBinMax) THEN
         WRITE(*,    *) ' ### STOP in MCellA_Initialize, to big m_nBin =',m_nBin !
         WRITE(m_Out,*) ' ### STOP in MCellA_Initialize, to big m_nBin =',m_nBin !
         STOP
      ENDIF
      IF( m_Dimen .LE. 0 ) THEN
         WRITE(*,    *) ' ### STOP in MCellA_Initialize, m_Dimen =',m_Dimen !
         WRITE(m_Out,*) ' ### STOP in MCellA_Initialize, m_Dimen =',m_Dimen !
         STOP
      ENDIF
* Initialize cells
      CALL MCellA_InitCells(funW)
***** CALL MCellA_BufPrint(m_Out)

      CALL  MCellA_Grow(funW)
* Update list of active cells, only for internal tests
      CALL MCellA_ActUpda
      CALL MCellA_Check(6,0)     ! Check if the liked list is OK
*     -----------------------
      IF( m_Chat.GE.1) THEN
            WRITE(m_Out,'( 2(a,i9), 2(a,g18.9) )') 
     $      'Initialize>>>>GROWTH Cells:',m_LastCe,' Active:',m_LastAc, !
     $      ' Integral:',m_CeIntg(1),' Driver:',m_CeDriv(1) !
      ENDIF
      IF( m_Chat.EQ.2) THEN
         CALL MCellA_BufPrint(    m_Out)
         CALL MCellA_BufActPrint( m_Out)
      ENDIF
* Initializations for M.C. generation
      m_Drive  = m_CeDriv(1)  ! M.C. generation value of Driver integral
      m_SumWt  = 0d0          ! M.C. generation sum of Wt
      m_SumWt2 = 0d0          ! M.C. generation sum of Wt**2
      m_NevGen  = 0d0         ! M.C. generation sum of 1d0
      m_WtMax  = -1d99        ! M.C. generation maximum wt
      m_WtMin  =  1d99        ! M.C. generation minimum wt
      m_VolTot = m_CeIntg(1)  ! Estimate of integral tot. without error
      m_MCresult = m_VolTot   ! M.C. generation Final value of ITEGRAL, temporary asignment
      m_MCerror  = m_VolTot   ! M.C. generation Final walue of ERROR  , temporary asignment
*
*((((((((((((################################################################################
*((((((((((((################################################################################
c      CALL MCellA_BufPrint(   6)
c      CALL MCellA_BufActPrint(6)
c      CALL MCellA_Check(      6,0)
c      WRITE(*,*) ' ########### STOP ########### developement not finished @@@@' !
c      STOP
*))))))))))))################################################################################
*))))))))))))################################################################################
*
* Cumulative Primary for MC generation, see MCellA_CellGener
      CALL MCellA_ActUpda
      TotPrim = 0d0
      m_CePrCu(0)= 0d0
      DO kCell = 1,m_LastAc
         iCell  = m_ActC(kCell)
         TotPrim = TotPrim +m_CePrim( iCell )
         m_CePrCu(kCell)=TotPrim
      ENDDO

      END                       ! MCellA_Initialize

      SUBROUTINE MCellA_InitCells(funW)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Initialize first n-factorial cells inside original cube                        //
*//   MC exploration done for all newly defined cells                                //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      DOUBLE PRECISION   funW
      EXTERNAL           funW
      INTEGER            iCeNew,iCell,NoMC
      INTEGER            i,j,k
*     -----------------------------------------------------------------------------
*//////////////////////////////////////////////////////////////////////////////////////
*        ROOT cell ACTIVE, no daughters
      NoMC= m_nSampl
*     -------------------- Stat,Pare, Dau1, Dau2, MCsampl,  iCeNew)
      CALL MCellA_DefCell(     1,  -1,   -1,   -1,    NoMC,  iCeNew) !
      CALL MCellA_Explore(iCeNew,funW) ! Initial MC sampling
      END                       !!!MCellA_InitCells

      SUBROUTINE MCellA_DefCell(Stat,Pare,Dau1,Dau2,NoMC,iCeNew)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Create new (daughter) cell and append it at the very end of the buffer         //
*//   iCeNew is pointer of the new cell                                              //
*//   Note clever trick: volume of this daughter is assigned initialy half volume    //
*//   of the parent, if parent exists.                                               //
*//   In Explore this value is used to update all parents such that                  //
*//   in the entrire tree parents have volume being sum of all daughter volumes.     //
*//   This summation discipline is useful for MC generation of an active cell by     //
*//   going randomly from top to bottom of the tree.                                 //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER            Stat,Pare,Dau1,Dau2,iCeNew,k,NoMC
*     ------------------------------------------------------------------
      IF( m_LastCe .EQ. m_nBuf) THEN
         WRITE(*,*) ' STOP in MCellA_DefCell: something wrong with m_nBuf=',m_nBuf !
         STOP
      ENDIF
      m_LastCe = m_LastCe+1
      iCeNew   = m_LastCe
      m_CeStat(iCeNew)= Stat                    ! status code, =0 inactive, =1 active
      m_CePare(iCeNew)= Pare                    ! parent cell pointer
      m_CeDau1(iCeNew)= Dau1                    ! daughter1 cell pointer
      m_CeDau2(iCeNew)= Dau2                    ! daughter2 cell pointer
      m_CeSamp(iCeNew)= NoMC                    ! No of MC events in exploration
*
      IF(Pare.EQ.-1) THEN
         m_CeIntg(iCeNew)= 0d0
         m_CeDriv(iCeNew)= 0d0
      ELSE
         m_CeIntg(iCeNew)= m_CeIntg(Pare)/2d0   ! integr. half of parent
         m_CeDriv(iCeNew)= m_CeDriv(Pare)/2d0   ! integr. half of parent
      ENDIF
      END                       ! MCellA_DefCell


      SUBROUTINE MCellA_Explore(iCell,funW)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Explore newly defined cell with help of special short MC sampling              //
*//   As a result, estimetes of true and driver integral will be defined             //
*//   Average and dispersion of the weight distribution will be found along each     //
*//   edge and the best edge (minimum dispersion) is memorized for future use.       //
*//   Axerage x for eventual future cell division is also defined.                   //
*//   Recorded are aso minimum and maximu weight etc.                                //
*//   The volume estimate in all (inactive) parent cells is updated                  //
*//   Note that links to parents and initial volume = 1/2 parent has to be           //
*//   already defined prior to calling this routine.                                 //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER            iCell
* Hyper-Cubic subspace
      DOUBLE PRECISION   Alpha( m_KdiMax)
      INTEGER            digit( m_KdiMax)
* Total space
      DOUBLE PRECISION   Vrand( m_DimMax)
* Edge sampling working space, matrices
      DOUBLE PRECISION   Xdivi( m_KdiMax)
      DOUBLE PRECISION   Histo( m_KdiMax,m_nBinMax)
*--------
      INTEGER            loop,i,j,k,parent,iv,jv,kv,iBin,nDivi,NevEff !
      DOUBLE PRECISION   x,x1,x2,Wt,Vsum,SumWt,NoMC
      DOUBLE PRECISION   Dx,VolOld, DriOld, XrSum
      DOUBLE PRECISION   Posi(m_KdiMax),Size(m_KdiMax)
      DOUBLE PRECISION   CeSum(10)
      DOUBLE PRECISION   funW
      EXTERNAL           funW
*-----------------------------------------------------------------------
* memorize old values, will be needed for correcting parent cells
      VolOld = m_CeIntg(iCell)
      DriOld = m_CeDriv(iCell)
* get position and size vectors from PARENT explorations
      CALL MCellA_GetHcube(iCell,Posi,Size)
      Dx=1d0          ! Cartesian volume of the hypercube
      DO i=1,m_Kdim
         Dx = Dx*Size(i) ! Product of sizes in hypercubical subspace
      ENDDO
*/////////////////////////////////////////////////////
*//    Exploratory MC sampling to probe the cell    //
*/////////////////////////////////////////////////////
      CeSum(1) =  0
      CeSum(2) =  0
      CeSum(3) =  0
      CeSum(4) =  1d90  ! wtmin
      CeSum(5) = -1d90  ! wtmax
      DO k=1,m_KdiMax
         DO iBin=1,m_nBin
            Histo(k,iBin)=0d0
         ENDDO
      ENDDO
*///////////////////////////////////////////////////////////////////////////////////
*     Additional scan over vertices in order to improve max/min weights
*     Note that this option adds 2**m_Kdim of the function calls, limited to 1000!
      IF( m_OptEdge .EQ. 1 ) THEN
         DO k=1,m_Kdim
            digit(k)=0          ! initialize first partitions
         ENDDO
         DO loop=1,1000         ! start of loop over partitions
            DO j=1,m_Kdim
               Vrand(j) = Posi(j) + digit(j)*Size(j) ! h-cubical subspace
            ENDDO
            Wt =funW(Vrand)*Dx  ! weight average normalised to integral over the cell
            CeSum(4) = MIN( CeSum(4),Wt) ! minium weight
            CeSum(5) = MAX( CeSum(5),Wt) ! maximu weight
            digit(1)=digit(1)+1
            DO k=1,m_Kdim-1
               IF(digit(k).EQ.2) THEN
                  digit(k)=0
                  digit(k+1)=digit(k+1)+1
               ENDIF
            ENDDO
            IF( m_Kdim .EQ.0 )      GOTO 122
            IF( digit(m_Kdim).EQ.2) GOTO 122
         ENDDO                  ! end of loop over partitions
 122     CONTINUE
      ENDIF
*///////////////////////////////////////////////////////////////////////////////////
*     generate randomly/uniformly vector Vrand inside this simplex&hypercube
      DO i=1,m_CeSamp(iCell)
         CALL MCellA_MakeAlpha( Alpha)
         DO j=1,m_Kdim
            Vrand(j) = Posi(j) +Alpha(j)*Size(j) ! hypcubic subspace
         ENDDO
*------------------------------------------------------------------------------------
* IMPORTANT! Two Loops below determine the indexing of edges (simplex and hypercube)
*------------------------------------------------------------------------------------
         DO j=1,m_Kdim
            Xdivi(j) = Alpha(j)
         ENDDO
*///////////////////////////////////////////////////////////////////////////////////
         Wt =funW(Vrand)*Dx  ! principal weight normalised to integral over the cell
*------------------------------------------------------------------------------------
         m_nCalls = m_nCalls+1
         CeSum(1) = CeSum(1)+ Wt         ! sum of weights
         CeSum(2) = CeSum(2)+ Wt*Wt      ! sum of weights squared
         CeSum(3) = CeSum(3)+ 1d0        ! sum of 1
         CeSum(4) = MIN( CeSum(4),Wt)    ! minium weight
         CeSum(5) = MAX( CeSum(5),Wt)    ! maximu weight
* Search for the best edge candidate for future cell division, prepare MC material
         Ndivi  = m_kDim
         DO k=1,nDivi
            iBin = INT(Xdivi(k)*m_nBin)+1d0
            iBin = MIN(MAX(iBin,0),m_nBin)
            Histo(k,iBin) = Histo(k,iBin)+Wt             ! fill histo for each edge
c[[[[[[[[[[[[ debug [[[[[[[[[[[[ debug [[[[[[[[[[[[
c            IF(iCell.EQ.4) THEN
c               CALL GLK_Fil1(1200+k, Xdivi(k),Wt)
c            ENDIF
c]]]]]]]]]]]] debug ]]]]]]]]]]]] debug ]]]]]]]]]]]]
         ENDDO
         IF( m_EvPerBin.GT.0 ) THEN
            NevEff = CeSum(1)**2/CeSum(2)
            IF( NevEff .GE. m_nBin*m_EvPerBin) GOTO 222 !
         ENDIF
      ENDDO
 222  CONTINUE
*///////////////////////////////////////////////////////
*//   End of Special Short MC sampling to probe cell  //
*///////////////////////////////////////////////////////


*//////////////////////////////////////////////////////////////////////////////////////
*//  Determine the best edge candidate for future cell division, 
*//  using MC  material in Histo
      SumWt  = CeSum(1)
      NoMC   = CeSum(3)
      CALL MCellA_Carver(iCell,SumWt,Histo)
*//////////////////////////////////////////////////////////////////////////////////////
      IF( CeSum(1) .LT.0d0) GOTO 920
      m_CeIntg(iCell)  = CeSum(1)/NoMC      ! estimator of the true integral
*!!!!!!!!!  DRIVER is for the Foam build-up (not for MC generation)   !!!!!!!!!!
*!!!!!!!!!  PRIMARY is for MC generation (not for the Foam build-up ) !!!!!!!!!!
      IF(     m_OptDrive.EQ.0 ) THEN
         m_CePrim(iCell) = m_CeIntg(iCell)           ! True integral, MC generation
         m_CeDriv(iCell) = m_CeIntg(iCell)           ! True integral, Foam build-up
      ELSEIF( m_OptDrive.EQ.1 ) THEN
         m_CePrim(iCell) = DSQRT(CeSum(2)/NoMC)      ! Sqrt( <w>**2 + sigma**2 )=Sqrt(<w**2>)
         m_CeDriv(iCell) = DSQRT(CeSum(2)/NoMC -m_CeIntg(iCell)**2) ! sigma=Sqrt(<w**2>-<w>**2)
      ELSEIF( m_OptDrive.EQ.2 ) THEN
         m_CePrim(iCell) = CeSum(5)                  ! wtmax    , MC generation
         m_CeDriv(iCell) = CeSum(5) -m_CeIntg(iCell) ! wtmax-<w>, Foam build-up
      ELSE
         WRITE(m_out,*) ' ++++ STOP in MCellA_Explore, wrong m_OptDrive =',m_OptDrive !
         WRITE(    *,*) ' ++++ STOP in MCellA_Explore, wrong m_OptDrive =',m_OptDrive !
         STOP
      ENDIF
c{{{      WRITE(*,*) 'iCell=',iCell,NoMC,INT(CeSum(1)**2/CeSum(2))
* correct volume and driver in all parent cells to the top of the tree
      parent = m_CePare(iCell)
      DO i = 1,m_nBuf
         IF( parent .EQ. -1 ) GOTO 100 ! Exit if no parent exists
         m_CeIntg(parent)  = m_CeIntg(parent)  +( m_CeIntg(iCell)  -VolOld) !
         m_CeDriv(parent)  = m_CeDriv(parent)  +( m_CeDriv(iCell)  -DriOld) !
         parent=m_CePare(parent)
      ENDDO
 100  CONTINUE
      RETURN
 920  WRITE(*,*) ' ### STOP in MCellA_Explore: something wrong with integrand ' !
      STOP
 970  WRITE(*,*) ' ### STOP in MCellA_Explore: something wrong with Ndivi =',nDivi !
      STOP
      END                       ! MCellA_Explore


      SUBROUTINE MCellA_Carver(iCell,SumWt,Histo)  !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*// Determine the best edge candidate for future cell division, using MC  material   //
*// kBest is the best edge found, xBest and yBest are the best values of lambda      //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER            iCell
      DOUBLE PRECISION   SumWt, Histo(m_KdiMax,m_nBinMax)
      DOUBLE PRECISION   xBest,yBest,zBest
      DOUBLE PRECISION   Bins(m_nBinMax)
      INTEGER            i,j,k, iBin, nDivi,kBest
      INTEGER            iUp,iLow, jUp,jLow, kDivi, jv,iv, jDivi
      DOUBLE PRECISION   BinMax,This, Carve, yLevel
      DOUBLE PRECISION   CarvOne,CarvTwo,CarvMax
*
      kBest =1
      xBest =0.5d0
      yBest =1d0
      IF( SumWt .NE. 0d0) THEN
         CarvMax = -1d150
         nDivi  = m_kDim
         DO kDivi=1,nDivi
            BinMax  = -1d150
            DO iBin=1,m_nBin    ! Unload histo and Maximum bin
               Bins(iBin) = Histo(kDivi,iBin)
               BinMax = MAX( BinMax, Bins(iBin)) ! Maximum content/bin
            ENDDO
            CarvTwo = 0d0
            DO iBin=1,m_nBin
               Bins(iBin) = Bins(iBin)/BinMax ! Normalize to the highest bin
               CarvTwo = CarvTwo + (1d0-Bins(iBin))/m_nBin ! Another carve (more stable)
            ENDDO
* Find maximum 'rectangular carve' in betwen the two bins (jLow,...,jUp)
            jLow =1
            jUp  =m_nBin
            CarvOne = -1d150
            yLevel  = -1d150
            DO iBin=1,m_nBin
               This = Bins(iBin)
               iLow = iBin
               DO j=iBin,1,-1   ! walk to the left and find first bin > current
                  IF(This .LT. Bins(j) ) GOTO 100
                  iLow = j
               ENDDO
 100           CONTINUE
               iUp  = iBin
               DO j=iBin,m_nBin ! walk to the right and find first bin > current
                  IF(This .LT. Bins(j) ) GOTO 200
                  iUp  = j
               ENDDO
 200           CONTINUE
               Carve = (iUp-iLow+1)*(1d0-This)/m_nBin
               IF( Carve .GT. CarvOne) THEN
                  CarvOne = Carve
                  jLow = iLow
                  jUp  = iUp
                  yLevel = This
               ENDIF
            ENDDO               ! end-loop over histogram bins 
*************************************************************
**               IF( CarvOne .GT. CarvMax) THEN
**                  CarvMax   = CarvOne
*************************************************************
            IF( CarvTwo .GT. CarvMax) THEN
               CarvMax   = CarvTwo
               kBest = kDivi    ! Best edge
               xBest = (jLow-1d0)/m_nBin
               yBest = (jUp*1d0)/m_nBin
               IF(jLow .EQ. 1 )     xBest = yBest
               IF(jUp  .EQ. m_nBin) yBest = xBest
* division ratio in units of 1/m_nBin, testing
               jDivi = jLow-1
               IF(jLow .EQ. 1 )     jDivi=jUp
**************************************************************
* The improvement below does not seem to matter at all
*                  IF( 0.5d0*(xBest+yBest) .LT. 0.5d0) THEN
*                     zBest =xBest
*                     xBest =yBest
*                     yBest =zBest
*                  ENDIF
**************************************************************
            ENDIF
         ENDDO                  ! end-loop over nDivi
      ENDIF
      m_CeDivi(iCell) = jDivi +kBest*32768 ! parameters for future division
      END                       ! MCellA_Carver


      SUBROUTINE  MCellA_GetHcube(iCell,Posi,Size)
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Testing new concept of the Cell encodong/decoding using short integers         //
*//   Using  m_CeDivi(iCell) we recover cell position Posi(tion) and Size vectors    //
*//   using all parents and grandparents in the tree.                                //
*//   The CPU overhead in generation is 50%                                          //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER           iCell
      DOUBLE PRECISION  Posi(*),Size(*)
      INTEGER           i,j,k, kBest, jDivi, parent,daughter
      DOUBLE PRECISION  xDivi
      DOUBLE PRECISION  sum1,sum2
*--------------------
      DO j=1,m_Kdim
         Size(j)=1d0
         Posi(j)=0d0
      ENDDO
* loop over parent cells to the top of the tree
      daughter = iCell
      parent   = m_CePare(iCell)
      DO i = 1,m_nBuf
         IF( parent .EQ. -1 ) GOTO 100 ! Exit if no parent exists
         jDivi = MOD(m_CeDivi(parent),32768) ! division bin < 32768
         kBest = m_CeDivi(parent)/32768      ! best edge 
         xDivi = (jDivi*1d0)/m_nBin
         IF(     m_CeDau1(parent).EQ.daughter  ) THEN
            Size(kBest)=Size(kBest)*xDivi
            Posi(kBest)=Posi(kBest)*xDivi
         ELSEIF( m_CeDau2(parent).EQ.daughter  ) THEN
            Size(kBest)=Size(kBest)*(1d0-xDivi)
            Posi(kBest)=Posi(kBest)*(1d0-xDivi)+xDivi
         ELSE
            WRITE(*,*) ' STOP in MCellA_TestNew, daughter,parent=',daughter,parent !
         ENDIF
         daughter = parent
         parent   = m_CePare(parent)
      ENDDO
 100  CONTINUE
      END                       ! MCellA_GetHcube


      SUBROUTINE MCellA_RanDiscr(Driv,nTot,Power,iRand)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//   PRESENTLY UNUSED !!!                                                           //
*//   Generates iRand in (1,nTot) acconding to discrete un-normalized probab. Driv   //
*//   Power is normaly =1, can be useful for special purposes                        //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      DOUBLE PRECISION   Driv(*),Power
      INTEGER            nTot,iRand
      INTEGER            i
      DOUBLE PRECISION   random,sum,Total
      REAL               Qrand(10)        ! from PseuMar
*
      Total   = 0d0
      DO i= 1,nTot
         Total = Total +Driv( i)**Power
      ENDDO
      IF(Total .EQ. 0d0) GOTO 990
      IF(m_OptRanLux.EQ.-1) THEN
         CALL PseuMar_MakeVec(Qrand,1)
      ELSE
         CALL RanLux(Qrand,1)
      ENDIF
      random = Qrand(1)
      iRand  = -1
      sum   = 0d0
      DO i= 1,nTot
         iRand  = i
         sum = sum +Driv( i)**Power
         IF( random .LT. sum/Total ) GOTO 100
      ENDDO
      IF(iRand .EQ. -1) GOTO 990
 100  CONTINUE
      RETURN
 990  WRITE(*,*) ' ### STOP in MCellA_RanDiscr, something went wrong !!!!'
      STOP
      END


      SUBROUTINE MCellA_MakeAlpha(Alpha)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                      //
*//   Provides random vector Alpha, each component in (0,1) range                        //
*//                                                                                      //
*//////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      DOUBLE PRECISION   Alpha(m_KdiMax), y
      REAL               Qrand( m_KdiMax)        ! from PseuMar
      INTEGER            i,k
*     --------------------------------------------------------
      IF( m_Kdim.LT.0 .OR. m_Kdim.GT.m_KdiMax) THEN
         WRITE(*,*) 'STOP in MCellA_MakeAlpha: m_Kdim=',m_Kdim
         STOP
      ENDIF
      IF(m_Kdim.LE.0) RETURN
      IF(m_OptRanLux.EQ.-1) THEN
         CALL PseuMar_MakeVec(Qrand,m_Kdim)
      ELSE
         CALL RanLux(Qrand,m_Kdim)
      ENDIF
      DO k =1,m_Kdim
         Alpha(k)=Qrand(k)
      ENDDO
      END



      SUBROUTINE MCellA_Grow(funW)     !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Grow new cells by division                                                     //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      DOUBLE PRECISION   funW
      EXTERNAL           funW
      INTEGER            i,RC,iCell
*---------------------------------------------
* Final division
      DO i=1,100000
         IF(  m_OptPeek .EQ. 0 ) THEN
            CALL MCellA_PeekMax(  iCell)       ! choose cell with maximum driver functional
         ELSE
            CALL MCellA_PeekRand1(iCell)       ! randomly choose one cell
         ENDIF
         CALL MCellA_Divide( iCell,funW,RC)    ! and divide it into two
c[[[[
c         CALL MCellA_BufPrint(    m_Out)
c]]]]
         IF(RC.EQ.-1) GOTO 300
      ENDDO
 300  CONTINUE
      WRITE(16,*) '######################### MCellA_Grow #####################'
*****[[[[[[ debug
***** CALL MCellA_BufPrint(    6)
***** CALL MCellA_BufActPrint( 6)
*****]]]]]]
      CALL MCellA_Check(6,0)
      END                       ! MCellA_Grow

      SUBROUTINE MCellA_PeekMax(iCell)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Find active cell containing maximum Driver functional  (foam built-up only)    //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER   iCell
      INTEGER   i
      DOUBLE PRECISION  DrivMax, Driv
*     ---------------------------------------------------
      iCell = 0
      DrivMax = -1d150
      DO i = 1,m_LastCe
         IF( m_CeStat(i).EQ.1 ) THEN
            Driv=  ABS(m_CeDriv(i))
            IF(Driv .GT. DrivMax) THEN
               DrivMax = Driv
               iCell = i
            ENDIF
         ENDIF
      ENDDO
****  WRITE(*,*) '###>>> MCellA_PeekMax: iCell=',iCell
      IF(iCell.EQ.0) THEN
         WRITE(*,*) '### STOP in MCellA_PeekMax: not found iCell=', iCell
         STOP
      ENDIF
      END                       ! MCellA_PeekMax


      SUBROUTINE MCellA_PeekRand1(iCell)     !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//       Peek up randomly TREE-WISE the pointer iCell of an active cell             //
*//                        Using DRIVER functional                                   //
*// We walk randomly from top of tree downwards until we find active cell m_CeStat=1 //
*// At each step one of daugters cells is choosen randomly according                 //
*// to their DRIVER functional estimates.                                            //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER            iCell
      INTEGER            kCell,i,Dau1,Dau2,iDau
      DOUBLE PRECISION   random,p1,volu1,volu2,volu,TotDri,sum
      REAL               Qrand(10)        ! from PseuMar
*     ----------------------------------------------------------------
      kCell=1
* All standard cells with 2 daughters
      DO i=1,10000000
         IF( m_CeStat( kCell ) .EQ. 1 ) GOTO 300
         volu1= m_CeDriv( m_CeDau1(kCell) )
         volu2= m_CeDriv( m_CeDau2(kCell) )
         p1 = volu1/(volu1+volu2)
         IF(m_OptRanLux.EQ.-1) THEN
            CALL PseuMar_MakeVec(Qrand,1)
         ELSE
            CALL RanLux(Qrand,1)
         ENDIF
         random = Qrand(1)
         IF( random .LT. p1 ) THEN
            kCell = m_CeDau1(kCell)
         ELSE
            kCell = m_CeDau2(kCell)
         ENDIF
      ENDDO
      GOTO 990
 300  CONTINUE
      iCell=kCell
      RETURN
 990  WRITE(*,*) ' ### STOP in MCellA_PeekRand1, something went wrong !!!!'
      STOP
      END                       !!! MCellA_PeekRand1


      SUBROUTINE MCellA_Divide(iCell,funW,RC)     !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Divide cell iCell into two daughter cells                                      //
*//   The iCell is retained and taged as inactive, daughter cells are appended       //
*//   at the end of the buffer.                                                      //
*//   New vertex is added to list of vertice.                                        //
*//   List of active cells is updated, iCell remooved, two daughters added           //
*//   and their properties set with help of MC sampling (MCellA_Explore)             //
*//   Return Code RC=-1 of buffer limit is reached,  m_LastCe=m_nBuf                 //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER            iCell,RC
      INTEGER            Dau1, Dau2
      DOUBLE PRECISION   funW
      EXTERNAL           funW
      INTEGER            Old1,Old2,j,k,jv,iv,nEdges,NoMC
c      DOUBLE PRECISION   Xave
*--------------------------------------------------------------------------------------
      RC = 0
      IF( m_LastCe+2 .GT. m_nBuf) GOTO 990 !! abort if no space in buffer
* reset cell as inactive
      m_CeStat(iCell) = 0
      NoMC= m_nSampl
* --------------------- Stat, Pare, Dau1,Dau2, MCsampl,iCeNew
      CALL MCellA_DefCell(  1, iCell,  -1,  -1,    NoMC,    Dau1) !
      CALL MCellA_DefCell(  1, iCell,  -1,  -1,    NoMC,    Dau2) !
      m_CeDau1(iCell) = Dau1
      m_CeDau2(iCell) = Dau2
      CALL MCellA_Explore(Dau1,funW)
      CALL MCellA_Explore(Dau2,funW)
* Update list of active cells, only for internal tests
      CALL MCellA_ActUpda
      RETURN
 990  RC=-1                     !!buffer limit is reached,  m_LastCe=m_nBuf
      RETURN
 980  WRITE(*,*) ' ### STOP in MCellA_Divide: too short list of vertices '
      STOP
      END                       ! MCellA_Divide



      SUBROUTINE MCellA_ActUpda     !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Create list of active cells (pointers)                                         //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER   iCell,Dau1,Dau2
      INTEGER   i
*     ---------------------------------------------------
      m_LastAc=0
      DO iCell = 1,m_LastCe
         IF( m_CeStat(iCell).EQ.1 ) THEN
            m_LastAc=m_LastAc+1
            IF(m_LastAc .EQ. m_cMax) GOTO 950
            m_ActC(m_LastAc) = iCell
         ENDIF
      ENDDO
      RETURN
 900  WRITE(*,*) '### STOP in MCellA_ActUpda: not found iCell=', iCell
      STOP
 950  WRITE(*,*) '### STOP in MCellA_ActUpda: list of active cells too short' !
      STOP
      END                       ! MCellA_ActUpda


      SUBROUTINE MCellA_CellGener(iCell)     !# Generation
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//       Peek up randomly pointer iCell of an active cell according to PRIMARY      //
*//       Straightforward way, using list of active pointes made by ActUpda          //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER            iCell
      INTEGER            kCell,i,Dau1,Dau2,iDau
      DOUBLE PRECISION   random,x1,TotPrim
      INTEGER            klower,kuper,krange,kurrent,DipSwitch
      REAL               Qrand(10)        ! from PseuMar
      INTEGER   iCont
      DATA      iCont/0/
      iCont = iCont+1
*     ----------------------------------------------------------------
      IF(m_OptRanLux.EQ.-1) THEN
         CALL PseuMar_MakeVec(Qrand,1)
      ELSE
         CALL RanLux(Qrand,1)
      ENDIF
      random = Qrand(1)
*     ---------------------------------------------------
      TotPrim = m_CePrCu(m_LastAc)
      x1 = TotPrim *random
      DipSwitch=0               ! =0 is faater
      IF( DipSwitch.EQ.1) THEN
*-------- primitive method --------
         DO kCell = 1,m_LastAc
            iCell = m_ActC(kCell)
            IF( m_CePrCu(kCell) .GE. x1 ) GOTO 800
         ENDDO
         WRITE(*,*) '### STOP1 in MCellA_CellGener: something wrong' !
         STOP
 800     CONTINUE
      ELSEIF( DipSwitch.EQ.0) THEN
*-------- a bit more sophisticated/faster method ------
         klower   = 0
         kuper    = m_LastAc
         DO i=1,m_LastAc
            krange   = (kuper-klower+1)/2
            kurrent  = klower +krange
            IF( x1 .LE. m_CePrCu(kurrent) ) THEN
               kuper = kurrent
            ELSE
               klower = kurrent
            ENDIF
            IF(kuper-klower.LE.1) GOTO 850
         ENDDO
         WRITE(*,*) ' STOP in MCellA_CellGener'
         STOP
 850     CONTINUE
         iCell = m_ActC(kuper)
         kCell = kuper
      ELSE
         iCell = m_ActC(1)      ! nonsense for tests
      ENDIF
***** IF(iCont.LE.10) WRITE(*,*) 'LastAc,kCell,iCell = ',m_LastAc,kCell,iCell !! debug
      END                       ! MCellA_CellGener


      SUBROUTINE MCellA_MakeEvent(funW)    !# Generation
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Generates point/vector Xrand with the weight MCwt                              //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      DOUBLE PRECISION   funW
      EXTERNAL           funW
      INTEGER            iCell,i,j,iv
      DOUBLE PRECISION   Wt,x1,x2,Dx,MCwt
      DOUBLE PRECISION   Alpha( m_KdiMax) ! Hyper-Cubic subspace
      DOUBLE PRECISION   Posi(m_KdiMax),Size(m_KdiMax)
*     -----------------------------------------------------------------
*     choose randomly one cell
      CALL MCellA_CellGener( iCell)
*     generate randomly/uniformly vector Vrand inside this simplex
      CALL MCellA_MakeAlpha( Alpha)
      CALL MCellA_GetHcube(iCell,Posi,Size)
      DO j=1,m_Kdim
         m_MCvector(j) = Posi(j) +Alpha(j)*Size(j) ! hypcubic subspace
      ENDDO
      Dx =1d0
      DO j=1,m_Kdim
         Dx=Dx*Size(j)
      ENDDO
* weight average normalised to PRIMARY integral over the cell
      MCwt =funW(m_MCvector)*Dx/m_CePrim(iCell) ! PRIMARY controls normalization
      m_nCalls =  m_nCalls+1
      m_MCwt   =  MCwt
* accumulation of statistics for the main MC weight
      m_SumWt  =  m_SumWt  +MCwt         ! sum of Wt
      m_SumWt2 =  m_SumWt2 +MCWt*MCwt    ! sum of Wt**2
      m_NevGen =  m_NevGen +1d0          ! sum of 1d0
      m_WtMax  =  MAX(m_WtMax,MCwt)      ! maximum wt
      m_WtMin  =  MIN(m_WtMin,MCwt)      ! minimum wt
      END                       ! MCellA_MakeEvent

      SUBROUTINE MCellA_GetMCvector(MCvector)    !# Generation
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      DOUBLE PRECISION  MCvector(*)
      INTEGER           k
*-----------------------
      DO k=1,m_Dimen
         MCvector(k)    = m_MCvector(k)
      ENDDO
      END

      SUBROUTINE MCellA_GetMCwt(MCwt)    !# Generation
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      DOUBLE PRECISION  MCwt
*-----------------------
      MCwt    = m_MCwt
      END

      SUBROUTINE MCellA_MCgenerate(funW,MCvector,MCwt)    !# Generation
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Obsolete                                                                       //
*//   Generates point/vector MCvector with the weight MCwt                           //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      DOUBLE PRECISION   MCvector(*),MCwt
      DOUBLE PRECISION   funW
      EXTERNAL           funW
      INTEGER            j
*     ---------------------------------------------------------------
      CALL MCellA_MakeEvent(funW)
      MCwt = m_MCwt
      DO j=1,m_Dimen
         MCvector(j) =m_MCvector(j)
      ENDDO
      END                       !!MCellA_MCgenerate


      SUBROUTINE MCellA_Finalize(MCresult,MCerror)    !# Finalization
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//   After MC run is completed it calculates integral and its error         //
*//   Also prints some information/statistics on the MC run                  //
*//   Remember that PRIMARY controls normalization of the integration        //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
*
      DOUBLE PRECISION     MCresult,MCerror,MCerelat
      DOUBLE PRECISION     Vtot,Verr,VerRela,TotPrim
      INTEGER              kCell,iCell
*-----------------------------------------------------------------------------
      MCresult =0d0
      MCerelat =1d0
      TotPrim = 0d0
      DO kCell = 1,m_LastAc
         iCell  = m_ActC(kCell)
         TotPrim = TotPrim +m_CePrim( iCell )
      ENDDO
      IF(m_NevGen .GT. 0) THEN
         MCresult = TotPrim *m_SumWt/m_NevGen
         IF(m_SumWt.NE.0d0)  MCerelat  = m_SumWt2/m_SumWt**2 -1d0/m_NevGen !
         IF(MCerelat.GT.0d0) MCerelat =  SQRT( ABS(MCerelat) ) !
         IF(MCerelat.LT.0d0) MCerelat = -SQRT( ABS(MCerelat) ) !
      ENDIF
      MCerror = MCresult*MCerelat
      Vtot=m_CeIntg(1)
* some test printouts
      IF(m_Chat.GT.0) THEN
      WRITE(m_Out,'(3a)') '||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||' !
      WRITE(m_Out,'(3a)') '||||||||||||||||||||||||||||||', ' MCellA_Finalize ', !
     $                    '||||||||||||||||||||||||||||||'
      WRITE(m_Out,'(a,2g18.9,f11.7)')               'MCresult, MCerror, Errela= ',MCresult,MCerror,MCerelat !
      WRITE(m_Out,'(a,2f11.5)')                     'Minimum maximum weight   = ',m_WtMin,m_WtMax !
      IF(m_NevGen .GT. 0) WRITE(m_Out,'(a,2f11.5)') 'Average wt SumWt/NevGen  = ',m_SumWt/m_NevGen !
      WRITE(m_Out,'(a,i15)')                        'Total of function calls  = ',m_nCalls !
      WRITE(m_Out,'(a,2i15)')                       'Number of cells          = ',m_LastCe !
      WRITE(m_Out,'(a,f12.1,2g18.9)')               'NevGen,SumWt,m_SumWt2    = ',m_NevGen,m_SumWt,m_SumWt2 !
      WRITE(m_Out,'(a,2g18.9)')                     'Integ.Est. from Explorat.= ',Vtot !
      WRITE(m_Out,'(3a)') '||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||' !
      ENDIF
      END       ! MCellA_Finalize



      SUBROUTINE MCellA_GetTotPrim(TotPrim)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Total integral from cell statistics, including initialization + MC generation  //
*//   It can be invoked just after initialization or after MC generation             //
*//   Note that this estimate is distorted slightly if vertices are included in      //
*//   the exploration of the cells.                                                  //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      INCLUDE 'MCellA.h'
      DOUBLE PRECISION  TotPrim,Sum
      INTEGER   kCell,  iCell      
      Sum = 0d0
      DO kCell = 1,m_LastAc
         iCell  = m_ActC(kCell)
         Sum = Sum +m_CePrim( iCell )
      ENDDO
      TotPrim=Sum
      END


      SUBROUTINE MCellA_SetKdim(Kdim)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER      Kdim
*     -------------------------------------------------
      CALL MCellA_PreInitialize
      m_Kdim = Kdim
      m_Dimen=m_Kdim
      END                       !!! MCellA_SetKdim

      SUBROUTINE MCellA_GetKdim(Kdim)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER      Kdim
*     -------------------------------------------------
      Kdim = m_Kdim
      END                       !!! MCellA_SetKdim

      SUBROUTINE MCellA_SetnBuf(nBuf)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER      nBuf
*     -------------------------------------------------
      CALL MCellA_PreInitialize
      m_nBuf = nBuf
      END                       !!! MCellA_SetnBuf

      SUBROUTINE MCellA_SetnBin(nBin)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER      nBin
*     -------------------------------------------------
      CALL MCellA_PreInitialize
      m_nBin = nBin
      END                       !!! MCellA_SetnBin

      SUBROUTINE MCellA_SetOut(Out)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER      Out
*     -------------------------------------------------
      CALL MCellA_PreInitialize
      m_Out = Out
      END                       !!! MCellA_SetOut

      SUBROUTINE MCellA_SetChat(Chat)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER      Chat
*     -------------------------------------------------
      CALL MCellA_PreInitialize
      m_Chat = Chat
      END                       !!! MCellA_SetChat

      SUBROUTINE MCellA_SetnSampl(nSampl)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER      nSampl
*     -------------------------------------------------
      CALL MCellA_PreInitialize
      m_nSampl = nSampl
      END                       !!! MCellA_SetnSampl

      SUBROUTINE MCellA_SetOptDrive(OptDrive)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER      OptDrive
*     -------------------------------------------------
      CALL MCellA_PreInitialize
      m_OptDrive = OptDrive
      END                       !!! MCellA_SetOptDrive

      SUBROUTINE MCellA_SetEvPerBin(EvPerBin)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER      EvPerBin
*     -------------------------------------------------
      CALL MCellA_PreInitialize
      m_EvPerBin = EvPerBin
      END                       !!! MCellA_SetEvPerBin


      SUBROUTINE MCellA_SetOptPeek(OptPeek)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER      OptPeek
*     -------------------------------------------------
      CALL MCellA_PreInitialize
      m_OptPeek = OptPeek
      END                       !!! MCellA_SetOptPeek

      SUBROUTINE MCellA_SetOptEdge(OptEdge)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER      OptEdge
*     -------------------------------------------------
      CALL MCellA_PreInitialize
      m_OptEdge = OptEdge
      END                       !!! MCellA_SetOptEdge

      SUBROUTINE MCellA_SetOptRanIni(OptRanIni)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER      OptRanIni
*     -------------------------------------------------
      CALL MCellA_PreInitialize
      m_OptRanIni = OptRanIni
      END                       !!! MCellA_SetOptRanIni

      SUBROUTINE MCellA_SetOptRanLux(OptRanLux)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER      OptRanLux
*     -------------------------------------------------
      CALL MCellA_PreInitialize
      m_OptRanLux = OptRanLux
      END                       !!! MCellA_SetOptRanLux

      SUBROUTINE MCellA_GetnCalls(nCalls)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER      nCalls
*     -------------------------------------------------
      nCalls = m_nCalls
      END                       !!! MCellA_SetnCalls

      SUBROUTINE MCellA_Check(mout,level)     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//  Checks all pointers, It is is a usefull autodiagnostic.                         //
*//                                                                                  //
*//  level=0, no printout, failures causes STOP                                      //
*//  level=1, printout, failures lead to WARNINGS only                               //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER       mout,level
      INTEGER       nFailures, iCell, Dau1,Dau2, Pare, iVe,n !
      INTEGER       NoEmpty, iError
*     ---------------------------------------------------------
      nFailures=0
      iError   =0
      IF(level.EQ.1) WRITE(mout,*)
     $'//////////////////////////////////////// MCellA_Checks /////////////////////////////////////////////' !
      DO iCell = 1,m_LastCe
         Dau1 = m_CeDau1(iCell)
         Dau2 = m_CeDau2(iCell)
         Pare = m_CePare(iCell)
* checking on parents
         IF(iCell.GT.1) THEN
            IF(Pare.GT.m_LastCe) THEN
               iError   =1
               nFailures = nFailures+1
               IF(level.EQ.1) WRITE(mout,*) '##### iCell= ',iCell,' Parent out of range = ',Pare !
            ENDIF
         ENDIF
         IF(iCell.GT.1) THEN
            IF(  (Pare.NE.1) .AND. (m_CeDau1(Pare).NE.iCell) .AND. (m_CeDau2(Pare).NE.iCell)  ) THEN !
               iError   =2
               nFailures = nFailures+1
               IF(level.EQ.1) 
     $              WRITE(mout,*) '##### iCell= ',iCell,' Parent not pointing to this daughter Pare= ',Pare !
            ENDIF
         ENDIF
* checking on daughters
         IF( Dau1 .GT. m_LastCe ) THEN
            iError   =3
            nFailures = nFailures+1
            IF(level.EQ.1) WRITE(mout,*) '##### iCell= ',iCell,' First  Daugter out of range Dau1= ',Dau1 !
         ENDIF
         IF( Dau2 .GT.m_LastCe ) THEN
            iError   =4
            nFailures = nFailures+1
            IF(level.EQ.1) WRITE(mout,*) '##### iCell= ',iCell,' Second Daugter out of range Dau2= ',Dau2 !
         ENDIF
         IF( Dau1.GE.1 .AND. Dau1.LE. m_LastCe) THEN
            IF( m_CePare(Dau1).NE.iCell ) THEN
               iError   =5
               nFailures = nFailures+1
               IF(level.EQ.1) 
     $              WRITE(mout,*) '##### iCell= ',iCell,' First  Daugter not pointing to parent Dau1= ',Dau1 !
            ENDIF
         ENDIF
         IF( Dau2.GE.1 .AND. Dau2.LE. m_LastCe) THEN
            IF( m_CePare(Dau2).NE.iCell ) THEN
               iError   =6
               nFailures = nFailures+1
               IF(level.EQ.1) 
     $              WRITE(mout,*) '##### iCell= ',iCell,' Second Daugter not pointing to parent Dau2= ',Dau2 !
            ENDIF
         ENDIF 
      ENDDO
* Check for empty cells
      NoEmpty = 0d0
      DO iCell = 1,m_LastCe
         IF( m_CeStat(iCell).EQ.1 ) THEN
            IF( m_CeDriv(iCell) .EQ. 0d0) NoEmpty = NoEmpty +1
         ENDIF
      ENDDO
      IF( NoEmpty.GT.0) THEN
         WRITE(mout,*) '++++++++++ MCellA_Check: !!! WARNING!!!! Empty Cells found NoEmpty= ',NoEmpty !
         WRITE(   *,*) '++++++++++ MCellA_Check: !!! WARNING!!!! Empty Cells found NoEmpty= ',NoEmpty !
      ENDIF
* summary
      IF(level.EQ.1) WRITE(mout,*) '++++++++++ MCellA_Check has found total ', nFailures, ' failures ' !
      IF(level.EQ.1) WRITE(mout,*)
     $'///////////////////////////////////////////////////////////////////////////////////////////////////' !
      IF(level.EQ.0 .AND. nFailures.GT.0 ) THEN
         WRITE(mout,*) '++++++++++ STOP in MCellA_Check, found total ', nFailures, ' failures ' !
         WRITE(mout,*) '++++++++++ iErro= ',iError
         STOP
      ENDIF
      END                       ! MCellA_Check



      SUBROUTINE MCellA_BufPrint(mout)     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   all cells                                                                      //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER            iCell,mout,active,j
      DOUBLE PRECISION   Posi(m_KdiMax),Size(m_KdiMax)
*     ----------------------------------------------------------------
      active  =0
      WRITE(mout,'(3a)') '==============================================', ' ALL-CELLS ',
     $                   '=============================================='
      WRITE(mout,'(3a)') ' iCell  Stat  Pare  Dau1  Dau2  Best      Xave      Drive   Ver1  Ver2  ...'
      DO iCell = 1, m_LastCe
         WRITE(mout,'(5i6,f11.5,20i6)')
     $        iCell, m_CeStat(iCell),  m_CePare(iCell), m_CeDau1(iCell), m_CeDau2(iCell), !
     $        m_CeDriv(iCell)                           ! Drive 
         IF(m_Kdim .GT. 0 ) THEN
            CALL MCellA_GetHcube(iCell,Posi,Size)
            WRITE(mout,'(a,50g12.6)')
     $           '      HypCubs Posit&Size: ',
     $           (Posi(j), j=1,m_Kdim), ! position
     $           (Size(j), j=1,m_Kdim)  ! size
         ENDIF
         IF(m_CeStat(iCell).EQ.1) active  = active +1
      ENDDO
      WRITE(mout,*) ' All cells: ',m_LastCe, ' Active: ', active
      END                       !! MCellA_BufPrint



      SUBROUTINE MCellA_BufActPrint(mout)     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   Active cells only                                                              //
*//   Side=1 indicates that this cell is "side leaf" sticking out of main branch     //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER            iCell,mout,active,Side,Pare,j
      DOUBLE PRECISION   VolRat,DriRat,VoluSum,DrivSum,RatMax,RatMin,Fact !
      DOUBLE PRECISION   Posi(m_KdiMax),Size(m_KdiMax)
*     ----------------------------------------------------------------
      WRITE(mout,'(3a)') '==================================================', ' ACTIVE CELLS ',
     $                   '=================================================='
      VoluSum =0d0
      DrivSum =0d0
      RatMin  =  1d60
      RatMax  = -1d60
      active  =0
      WRITE(mout,'(2a)') ' iCell Stat Pare Dau1 Dau2 Side',
     $                   '     <w>    Sig/<w>      Drive    VolTrue  ' !
      DO iCell = 1, m_LastCe
         IF(m_CeStat(iCell).EQ.1) THEN
            side=0
            Pare = m_CePare(iCell)
            IF(Pare.GT.0) THEN
               IF( m_CeStat(m_CeDau1(Pare))*m_CeStat(m_CeDau2(Pare)) .EQ. 0  ) Side=1 !
            ENDIF
            VolRat = m_CeIntg(iCell)* m_LastAc/m_CeDriv(1)
            DriRat = m_CeDriv(iCell)* m_LastAc/m_CeDriv(1)
            RatMin = Min(RatMin,VolRat)
            RatMax = Max(RatMax,VolRat)
            WRITE(mout,'(6i5, 3f11.5 ,10i5)') 
     $           iCell, m_CeStat(iCell),  m_CePare(iCell),  m_CeDau1(iCell),m_CeDau2(iCell),  side, !
     $           m_CeIntg(iCell) /(m_CeDriv(iCell)+1d-100), ! average weight
     $           DriRat,                 ! Drive/DriTot*Ncell
     $           VolRat                  ! TrueVolu/VolTot*Ncell
            IF(m_Kdim .GT. 0 ) THEN
               CALL MCellA_GetHcube(iCell,Posi,Size)
               WRITE(mout,'(a,50g12.6)')
     $              '      HypCubs Posit&Size: ',
     $              (Posi(j), j=1,m_Kdim), ! position
     $              (Size(j), j=1,m_Kdim)  ! size
            ENDIF
            VoluSum = VoluSum +m_CeIntg(iCell)
            DrivSum = DrivSum +m_CeDriv(iCell)
            active  = active +1
         ENDIF
      ENDDO
      WRITE(mout,'(a,i6,a,2i6)') 'All cells: ',m_LastCe, '      Active: ', active, m_LastAc !
      WRITE(mout,'(a,2f12.5)')   'Minimum and Maximum Volume/Tot*nCell= ', RatMin,RatMax !
      WRITE(mout,'(a,2g20.13)')  'Total True Integral in active cells = ', VoluSum, m_CeIntg(1) !
      WRITE(mout,'(a,2g20.13)')  'Total Driver Integ in active cells  = ', DrivSum, m_CeDriv(1) !
      WRITE(mout,'(a,f12.5)')    'True/Drive = ', VoluSum/DrivSum
      END                       !! MCellA_BufActPrint



      SUBROUTINE MCellA_PltBegin(ltx)     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   DEBUG                                                                          //
*//   Initialization, write header of TeX file                                       //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER   ltx
*---------------------------------------------------
      m_ltx  = ABS(ltx)
      IF(ltx .GT. 0 ) THEN
         WRITE(m_ltx,'(2A)') '\\newpage'
      ELSE
*------------------------------!
*           Header
*------------------------------!
         WRITE(m_ltx,'(A)') '\\documentclass[12pt]{article}'
         WRITE(m_ltx,'(A)') '\\usepackage{color}' !<-for colors!!!
         WRITE(m_ltx,'(A)') '\\usepackage{epic}' !<-for extended ploting
         WRITE(m_ltx,'(A)') '\\textwidth  = 16cm'
         WRITE(m_ltx,'(A)') '\\textheight = 18cm'
         WRITE(m_ltx,'(A)') '\\pagestyle{empty}'
         WRITE(m_ltx,'(A)') '\\begin{document}'
         WRITE(m_ltx,'(A)') '  '
         WRITE(m_ltx,'(A)') '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%' !
         WRITE(m_ltx,'(A)') '\\begin{figure}[!ht]'
         WRITE(m_ltx,'(A)') '\\centering'
*------------------------------!
* Frames and labels
*------------------------------!
         WRITE(m_ltx,'(A)') '% =========== big frame, title etc. ======='
         WRITE(m_ltx,'(A)') '\\setlength{\\unitlength}{0.1mm}'
         WRITE(m_ltx,'(A)') '\\begin{picture}(1600,1600)'
         WRITE(m_ltx,'(A)') '\\put(0,0){\\framebox(1600,1600){ }}'
      ENDIF
      END

      SUBROUTINE MCellA_PltCell     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   DEBUG                                                                          //
*//   Plot all simplectic cells                                                      //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
      INTEGER            iCell,active,j
      INTEGER            iV1,iV2,iV3
      INTEGER            kx1,ky1,kx2,ky2,kx3,ky3,kx,ky,lx,ly
      DOUBLE PRECISION   Posi(m_KdiMax),Size(m_KdiMax)
*---------------------------------------------------------------------------------------------
*                        Rectangular 2-dim FOAM
*---------------------------------------------------------------------------------------------
      IF(m_kDim.EQ.2) THEN
         WRITE(m_ltx,'(A)') '% =========== Vertices Vertices ==========='
         WRITE(m_ltx,'(A)') '\\put(0,0){\\begin{picture}( 1600,1600)' !
         DO iCell = 2, m_LastCe
            IF(m_CeStat(iCell).EQ.1) THEN ! Only active cells
               CALL MCellA_GetHcube(iCell,Posi,Size)
               kx = Posi(1)*1600
               ky = Posi(2)*1600
               lx = Size(1)*1600
               ly = Size(2)*1600
               kx1 = kx+lx/2
               ky1 = ky+ly/2
*     cell rectangle
               WRITE(m_ltx,'(A,I5,A,I5,A,I5,A,I5,A)') 
     $              '\\put(',kx,',',ky,'){\\color{black}\\framebox(',lx,',',ly,'){ }}' !
***               WRITE(m_ltx,'(A,I5,A,I5,A,I5,A,I5,A)') 
***     $              '\\put(',kx,',',ky,'){\\color{black}\\dashbox{7}(',lx,',',ly,'){ }}' !
*     cell number
               IF(m_LastCe.LE.250) WRITE(m_ltx,'(A,I4,A,I4,A,I4,A)') 
     $            '\\put(',kx1,',',ky1,'){\\makebox(0,0)[b]{\\hbox{\\small\\color{magenta}\\scriptsize ',iCell,' }}}' !
            ENDIF
         ENDDO
* Close frame
         WRITE(m_ltx,'(A)') '\\end{picture}}'
         WRITE(m_ltx,'(A)') '% ============== End Vertices ==========='
      ENDIF
      END                       !! MCellA_BufPrint

      SUBROUTINE MCellA_PltMisc     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   Miscelaneous                                                                   //
*//   Plot of frame for 2-dim void testing function                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
*
      WRITE(m_ltx,'(A)') '\\put(80,80){\\color{blue}\\dashbox{7}( 1440,1440){ }}' ! 5% edge band
      END                       !! MCellA_PltMisc

      SUBROUTINE MCellA_PltEnd     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   DEBUG                                                                          //
*//   Close Tex file with plot                                                       //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'MCellA.h'
*
      WRITE(m_ltx,'(A)') '\\end{picture}'
      WRITE(m_ltx,'(A)') '\\end{figure}'
      WRITE(m_ltx,'(A)') '\\end{document}'
      CLOSE(m_ltx)
      END

*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
